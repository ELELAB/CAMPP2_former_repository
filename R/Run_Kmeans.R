#' @title K-means clustering
#' @description A wrapper function for K-means clustering.
#' For data sets with >1000 features, multiple subsets (number of sets = number
#' of features/1000; rounded up to the higher integer) will be generated,
#' maximum is 10 subsets. A number of randomly selected features (e.g. genes)
#' in 1 subset is limited to 2000.
#' A number of clusters for each sub set is automatically estimated using BIC and
#' a consensus (based on all the subsets) of best n k-means is returned and used
#' for clustering.
#' If K-means estimation using BIC fails, a number of clusters will be based on
#' the number of samples (2-6 clusters for data set with less than 100 samples;
#' 2-11 for data sets with 101-500 samples, and 2-16 clusters for data sets with
#' more than 500 samples). The number of cluster can also be supplied manually.
#' As results, an information about the clusters assigned to each sample and
#' results PCA (FactoMineR) are provided.
#' The clusters are visualized on a PCA plot and saved into the png.
#' Plot of BIC values for each of the sample sub-set is saved into .png file.
#' A summary describing the best model is printed on the screen during
#' calculation.
#' @param data a data.frame of feature (e.g. gene) counts
#' @param show.PCA.labels a boolean value (TRUE or FALSE) specifying if elements
#' (e.g. samples) should be labelled in the PCA plot including information about
#' the clusters. Labeling is based on column names of the input data.
#' Default value is FALSE.
#' @param colors a vector of colors (one color for each cluster)
#' @param prefix a character string defining a prefix of output file.
#' @param num.km.clusters a vector of numbers of clusters expected in the data.
#' Clusters can be represented e.g., by sample groups, sub-types, etc.
#' If multiple values provided, the function will automatically
#' perform K-means clustering based on each (expected number of clusters) of
#' them separately. By default, expected numbers of clusters are calculated
#' automatically based on BIC (mclust package) applied to sub-sampled data sets.
#' A default value for this parameter is NULL.
#' @param seed a seed for K-means clustering. Defaults is NULL.
#' @param pca.scale a boolean, if TRUE then data are scaled to unit variance
#' during PCA. Default is FALSE
#' @export
#' @import factoextra
#' @import FactoMineR
#' @seealso
#' @return a list including:
#' 1) a data.frame with cluster information assigned to each sample;
#' 2) a PCA objects including data for generating PCA plots with cluster
#' information (generated by PCA function from FactoMineR package);
#' 2D PCA plot(s) projecting samples over first 2 principal components saved
#' into png.
#' plots of BIC values for each sample sub set are saved into .png file
#' @examples \dontrun{
#' runKmeans(campp2_brca_1_batchCorrected[1:2000,], show.PCA.labels = FALSE, colors=NULL,
#' prefix="test", num.km.clusters=NULL, seed=123, pca.scale=FALSE)
#' }

runKmeans <- function(data, show.PCA.labels = FALSE, prefix, colors=NULL, num.km.clusters=NULL, seed=NULL, pca.scale=FALSE){

    ###parse TRUE/FALSE into "all"/"none".
    if(show.PCA.labels==TRUE){
        show.PCA.labels<-"all"
    } else if (show.PCA.labels==FALSE) {
        show.PCA.labels=="none"
    } else {
        stop(paste0("The value ", show.PCA.labels, " defined as show.PCA.labels parameter is not supported. Supported values are TRUE/FALSE."))
    }

     if(is.null(prefix)){
        stop(print("Please, provide a prefix for the result files."))
     }

    if(!is.null(num.km.clusters)){
        nclus <- num.km.clusters
    } else {
        # Number of sample subsets to generate
        num.subsets <- 1:min(ceiling(nrow(data)/1000), 10)

        # Number of variables (genes) in each sample subset, limit is 2000.
        subset.size <- min(nrow(data),2000)

        # In case k-means estimation using BIC is not working, number of K-means is estimated based on a number of samples in the data
        if(ncol(data) <= 100) {
            cluster.counts.alt <- 2:6
        } else if (ncol(data) > 100 && ncol(data) <= 500) {
            cluster.counts.alt <- 2:11
        } else {
            cluster.counts.alt <- 2:16
        }

        list.of.subsets <- list()

        for (idx in 1:length(num.subsets)) {
            subset <- t(data[sample(nrow(data), subset.size), ])  #make random gene selections
            list.of.subsets[[idx]] <- subset  #create list of random selections
        }
        cat(paste0("\n", length(num.subsets), " clustering runs will be done in total...\n"))
        clusters.list <- lapply(list.of.subsets, function(x) EstimateKmeans(x)) #estimate how many clusters in the data subsets

        #extract cluster numbers from clusters.list
        cluster.counts<-list()
        for (i in 1:length(num.subsets)){
            cluster.counts[[i]] <- clusters.list[[i]]$num.km.clusters
        }

        #save BIC plots
        for (i in 1:length(num.subsets)){
            png(file=paste0(prefix,"_BIC_plot_subset_",i,".png"))
            plot(clusters.list[[i]]$BIC)
            dev.off()
        }

        nclus <- unique(unlist(cluster.counts))

        if (unique(is.na(nclus)) == TRUE) {
            cat(paste0("Number of clusters could not be determined using BIC. There may be little or poor clustering of samples. Alternatively, based on size of dataset, ", length(num.subsets), " sample sets will be generated of size ", subset.size, " and ", length(cluster.counts.alt), " clusters will be tested. \nRunning..."))
            nclus <- cluster.counts.alt
        }
    }

    nclus <- sort(nclus)
    paste0("Numbers of clusters being tested: ",nclus)

    res.pca <- PCA(t(data),  graph = FALSE, ncp=10, scale = pca.scale) # principal component analysis
    res.list <- list()

    for (idx in 1:length(nclus)) {
        set.seed(seed)
        Kclus <- kmeans(t(data), nclus[[idx]])
        Clusters <- as.factor(paste0("C",data.frame(Kclus$cluster)$Kclus.cluster))
        res.list[[idx]] <- Clusters
        if(length(colors) < nclus[[idx]]){
            print("Number of colours is defined by the number of groups and is smaller than the number of clusters. Colour scheme will be defined automatically.")
            colors <- NULL
        }
        fviz_pca_ind(res.pca,
                     label = show.PCA.labels, # show/hide individual labels; labels are taken from feature counts matrix automatically
                     habillage = as.factor(Clusters), # color by groups (clusters in this case)
                     palette = colors,
                     addEllipses = TRUE, # concentration ellipses
                     repel=TRUE,
                     ggtheme = theme_classic(),
                     title = paste0("k-means ", nclus[[idx]], " clusters"),
                     labelsize = 2

        )
        ggsave(paste0(prefix,"_PCA_Kmeans_C",nclus[[idx]],".png"))

    }
    names(res.list) <- paste0("Clus", nclus)
    res.clusters <- as.data.frame(res.list)

    return(list("res.clusters"=res.clusters,"res.pca"=res.pca))

}
